# 第8章 モバイルアプリケーション開発

> 本章では、Go-Zero契約ファイルを中心とした統合開発環境により、Flutter、React Nativeなどのモバイルアプリケーション開発について解説します。

---

## 第1節 モバイル向け統合アーキテクチャ

### 8.1.1 アーキテクチャ概要

Winyxプロジェクトでは、**マイクロサービス対応の契約ファイル**（user_service、task_service、message_service）からWeb、モバイルすべてのクライアントコードを生成し、一貫性のある開発体験を提供します。

#### 全体アーキテクチャ図

```
                    ┌─────────────────────────────────┐
                    │        Go-Zero 契約ファイル群       │
                    │   user.api / task.api / message.api │
                    └─────────────────┬───────────────┘
                                    │
           ┌────────────────────────┼────────────────────────┐
           │                        │                        │
           ▼                        ▼                        ▼
    ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
    │ TypeScript  │        │    Dart     │        │   Swift     │
    │  (Next.js)  │        │ (Flutter)   │        │   (iOS)     │
    └─────────────┘        └─────────────┘        └─────────────┘
           │                        │                        │
           ▼                        ▼                        ▼
    ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
    │ Web Client  │        │Mobile Client│        │ iOS Client  │
    └─────────────┘        └─────────────┘        └─────────────┘
           │                        │                        │
           │ 開発時: HTTP/REST      │ HTTP/REST             │ HTTP/REST
           │ 本番時: API Routes     │                        │
           │         ↓ RPC          │                        │
           └────────────────────────┼────────────────────────┘
                                    │
                                    ▼
                    ┌─────────────────────────────────┐
                    │       Go-Zero マイクロサービス群     │
                    │  ┌─────────────┐ ┌─────────────┐│
                    │  │UserService  │ │TaskService  ││
                    │  │ (Port 8888) │ │ (Port 8889) ││
                    │  └─────────────┘ └─────────────┘│
                    │  ┌─────────────┐ ┌─────────────┐│
                    │  │MessageSvc   │ │ RPC Services││
                    │  │ (Port 8890) │ │ (内部通信)   ││
                    │  └─────────────┘ └─────────────┘│
                    └─────────────────────────────────┘
```

### 8.1.2 クライアント別通信方式

| クライアント | 開発環境 | 本番環境 | 特徴 |
|------------|----------|----------|------|
| **Next.js Web** | HTTP → Microservices | API Routes → RPC | SSR対応、高速内部通信 |
| **Flutter Mobile** | HTTP → Microservices | HTTP → Gateway | クロスプラットフォーム |
| **React Native** | HTTP → Microservices | HTTP → Gateway | ネイティブ性能 |
| **iOS/Android** | HTTP → Microservices | HTTP → Gateway | 完全ネイティブ |

### 8.1.3 統合開発のメリット

- **統一された型定義**: 単一の契約ファイルからすべてのプラットフォーム向け型を生成
- **仕様の一貫性**: バックエンドとすべてのクライアント間での仕様齟齬を防止
- **開発効率の向上**: プラットフォーム毎の手動コーディングが不要
- **保守性の向上**: 契約変更時の自動同期により修正漏れを防止

---

## 第2節 Flutter開発環境の構築

### 8.2.1 Flutter用コード生成ツール

既に実装済みのFlutter用コード生成ツールについて詳しく説明します。

- [ ] Flutter用コード生成ツールの確認
```bash
vim /var/www/winyx/scripts/generate_flutter_code.js
```

このツールの主な機能：
- マイクロサービス別Go-Zero契約ファイルの解析
- Dartクラス定義の自動生成（user/task/message別）
- マイクロサービス対応APIクライアントの自動生成
- サービス間通信のシリアライゼーション機能の実装

### 8.2.2 生成されるDartクラス

Go-Zero契約ファイルから以下のようなDartクラスが生成されます：

```dart
class LoginReq {
  /// ユーザーのメールアドレス
  final String email;
  
  /// ユーザーのパスワード
  final String password;

  const LoginReq({
    required this.email,
    required this.password,
  });

  factory LoginReq.fromJson(Map<String, dynamic> json) {
    return LoginReq(
      email: json['email'],
      password: json['password'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'email': email,
      'password': password,
    };
  }

  @override
  String toString() {
    return 'LoginReq{email: $email, password: $password}';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is LoginReq &&
        other.email == email &&
        other.password == password;
  }

  @override
  int get hashCode {
    return Object.hash(email, password);
  }
}
```

### 8.2.3 生成されるAPIクライアント

```dart
class WinyxApiClient {
  final String baseUrl;
  final Map<String, String> _defaultHeaders;
  final Duration timeout;
  String? _authToken;

  WinyxApiClient({
    required this.baseUrl,
    Map<String, String>? headers,
    this.timeout = const Duration(seconds: 30),
  }) : _defaultHeaders = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    ...?headers,
  };

  /// 認証トークンを設定
  void setAuthToken(String token) {
    _authToken = token;
  }

  /// ログインAPI
  Future<LoginRes> login(LoginReq request) async {
    return _post<LoginRes>(
      '/api/auth/login',
      request.toJson(),
      LoginRes.fromJson,
    );
  }

  // その他のAPIメソッドも自動生成される...
}
```

### 8.2.4 Flutter依存関係の設定

生成されたコードを使用するために必要な依存関係：

```yaml
# pubspec.yaml
dependencies:
  flutter:
    sdk: flutter
  http: ^1.1.0
  json_annotation: ^4.8.1

dev_dependencies:
  json_serializable: ^6.7.1
  build_runner: ^2.4.7
  flutter_lints: ^3.0.1
```

---

## 第3節 Flutter実装例

### 8.3.1 認証サービスの実装

- [ ] AuthServiceの作成
```dart
// lib/services/auth_service.dart
import '../generated/api_client.dart';
import '../generated/models.dart';
import 'package:shared_preferences/shared_preferences.dart';

class AuthService {
  final WinyxApiClient _apiClient;
  static const String _tokenKey = 'auth_token';
  
  AuthService() : _apiClient = WinyxApiClient(
    baseUrl: _getBaseUrl(),
  );

  static String _getBaseUrl() {
    // 環境に応じてベースURLを切り替え
    const bool isProduction = bool.fromEnvironment('dart.vm.product');
    if (isProduction) {
      return 'https://winyx.jp';
    } else {
      return 'http://10.0.2.2:8888'; // Android Emulator用（APIゲートウェイ）
      // return 'http://localhost:8888'; // iOS Simulator用（APIゲートウェイ）
    }
  }
  
  static Map<String, String> getMicroserviceUrls() {
    const bool isProduction = bool.fromEnvironment('dart.vm.product');
    if (isProduction) {
      return {
        'user': 'https://winyx.jp/api/user',
        'task': 'https://winyx.jp/api/task',
        'message': 'https://winyx.jp/api/message',
      };
    } else {
      return {
        'user': 'http://10.0.2.2:8888',
        'task': 'http://10.0.2.2:8889', 
        'message': 'http://10.0.2.2:8890',
      };
    }
  }

  /// ログイン
  Future<LoginRes> login(String email, String password) async {
    final request = LoginReq(
      email: email,
      password: password,
    );
    
    try {
      final response = await _apiClient.login(request);
      
      // 認証トークンを保存
      await _saveToken(response.accessToken);
      _apiClient.setAuthToken(response.accessToken);
      
      return response;
    } catch (e) {
      throw AuthException('ログインに失敗しました: ${e.toString()}');
    }
  }

  /// 自動ログイン（アプリ起動時）
  Future<bool> tryAutoLogin() async {
    final token = await _getStoredToken();
    if (token == null) return false;

    try {
      _apiClient.setAuthToken(token);
      // トークンの有効性をチェック
      await _apiClient.userInfo();
      return true;
    } catch (e) {
      // トークンが無効な場合は削除
      await _clearToken();
      return false;
    }
  }

  /// ログアウト
  Future<void> logout() async {
    try {
      await _apiClient.logout();
    } finally {
      await _clearToken();
      _apiClient.clearAuthToken();
    }
  }

  // プライベートメソッド
  Future<void> _saveToken(String token) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_tokenKey, token);
  }

  Future<String?> _getStoredToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_tokenKey);
  }

  Future<void> _clearToken() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_tokenKey);
  }
}

class AuthException implements Exception {
  final String message;
  const AuthException(this.message);
  
  @override
  String toString() => message;
}
```

### 8.3.2 状態管理（Provider使用）

- [ ] 認証状態の管理
```dart
// lib/providers/auth_provider.dart
import 'package:flutter/material.dart';
import '../services/auth_service.dart';
import '../generated/models.dart';

class AuthProvider with ChangeNotifier {
  final AuthService _authService = AuthService();
  
  LoginRes? _user;
  bool _isLoading = false;
  bool _isAuthenticated = false;

  LoginRes? get user => _user;
  bool get isLoading => _isLoading;
  bool get isAuthenticated => _isAuthenticated;

  AuthProvider() {
    _tryAutoLogin();
  }

  Future<void> _tryAutoLogin() async {
    _isLoading = true;
    notifyListeners();

    try {
      final success = await _authService.tryAutoLogin();
      if (success) {
        // ユーザー情報を取得
        await _loadUserInfo();
      }
    } catch (e) {
      debugPrint('Auto login failed: $e');
    }

    _isLoading = false;
    notifyListeners();
  }

  Future<bool> login(String email, String password) async {
    _isLoading = true;
    notifyListeners();

    try {
      final response = await _authService.login(email, password);
      _user = response;
      _isAuthenticated = true;
      _isLoading = false;
      notifyListeners();
      return true;
    } catch (e) {
      _isLoading = false;
      notifyListeners();
      throw e;
    }
  }

  Future<void> logout() async {
    try {
      await _authService.logout();
    } finally {
      _user = null;
      _isAuthenticated = false;
      notifyListeners();
    }
  }

  Future<void> _loadUserInfo() async {
    try {
      // ここでユーザー情報を取得するAPIを呼び出し
      // final userInfo = await _authService.getUserInfo();
      // _user = userInfo;
      _isAuthenticated = true;
    } catch (e) {
      debugPrint('Failed to load user info: $e');
      await logout();
    }
  }
}
```

### 8.3.3 ログイン画面の実装

- [ ] LoginScreenの作成
```dart
// lib/screens/login_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends StatefulWidget {
  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    
    try {
      final success = await authProvider.login(
        _emailController.text.trim(),
        _passwordController.text,
      );

      if (success && mounted) {
        Navigator.of(context).pushReplacementNamed('/dashboard');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(e.toString()),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Center(
            child: SingleChildScrollView(
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // ロゴ
                    Icon(
                      Icons.account_circle,
                      size: 80,
                      color: Theme.of(context).primaryColor,
                    ),
                    const SizedBox(height: 32),

                    // タイトル
                    Text(
                      'Winyxにログイン',
                      style: Theme.of(context).textTheme.headlineMedium,
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 32),

                    // メールアドレス入力
                    TextFormField(
                      controller: _emailController,
                      keyboardType: TextInputType.emailAddress,
                      decoration: const InputDecoration(
                        labelText: 'メールアドレス',
                        prefixIcon: Icon(Icons.email),
                        border: OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'メールアドレスを入力してください';
                        }
                        if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
                            .hasMatch(value)) {
                          return '有効なメールアドレスを入力してください';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // パスワード入力
                    TextFormField(
                      controller: _passwordController,
                      obscureText: _obscurePassword,
                      decoration: InputDecoration(
                        labelText: 'パスワード',
                        prefixIcon: const Icon(Icons.lock),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility
                                : Icons.visibility_off,
                          ),
                          onPressed: () {
                            setState(() {
                              _obscurePassword = !_obscurePassword;
                            });
                          },
                        ),
                        border: const OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'パスワードを入力してください';
                        }
                        if (value.length < 6) {
                          return 'パスワードは6文字以上で入力してください';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 24),

                    // ログインボタン
                    Consumer<AuthProvider>(
                      builder: (context, authProvider, child) {
                        return ElevatedButton(
                          onPressed: authProvider.isLoading 
                              ? null 
                              : _handleLogin,
                          style: ElevatedButton.styleFrom(
                            padding: const EdgeInsets.symmetric(vertical: 16),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          child: authProvider.isLoading
                              ? const SizedBox(
                                  height: 20,
                                  width: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                  ),
                                )
                              : const Text(
                                  'ログイン',
                                  style: TextStyle(fontSize: 16),
                                ),
                        );
                      },
                    ),

                    const SizedBox(height: 16),

                    // 新規登録リンク
                    TextButton(
                      onPressed: () {
                        Navigator.of(context).pushNamed('/register');
                      },
                      child: const Text('アカウントを作成'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

---

## 第4節 React Native対応

### 8.4.1 React Native用コード生成

React Nativeでも同様の契約ファイルからTypeScript用APIクライアントを生成できます。

- [ ] React Native用生成スクリプトの実装
```javascript
// scripts/generate_react_native_code.js の一部
function generateReactNativeApiClient(endpoints, types) {
  let output = `import AsyncStorage from '@react-native-async-storage/async-storage';

class WinyxApiClient {
  private config: ApiConfig;
  private authToken?: string;

  constructor(config: ApiConfig) {
    this.config = {
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      ...config,
    };
  }

  async setAuthToken(token: string): Promise<void> {
    this.authToken = token;
    await AsyncStorage.setItem('auth_token', token);
  }

  private async request<T>(
    method: string,
    endpoint: string,
    data?: any
  ): Promise<T> {
    const url = \`\${this.config.baseURL}\${endpoint}\`;
    const headers = await this.getHeaders();

    const response = await fetch(url, {
      method,
      headers,
      body: data ? JSON.stringify(data) : undefined,
    });

    if (!response.ok) {
      throw new ApiException(\`Request failed: \${response.statusText}\`);
    }

    return response.json();
  }
`;

  // エンドポイント別メソッドを生成
  endpoints.forEach(endpoint => {
    // メソッド生成ロジック...
  });

  return output;
}
```

### 8.4.2 React Native実装例

- [ ] React Native用認証フック
```typescript
// src/hooks/useAuth.ts
import { useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { WinyxApiClient } from '../generated/api-client';
import { LoginReq, LoginRes } from '../generated/types';

const apiClient = new WinyxApiClient({
  baseURL: __DEV__ ? 'http://localhost:8888' : 'https://winyx.jp',
  // マイクロサービス対応
  userServiceURL: __DEV__ ? 'http://localhost:8888' : 'https://winyx.jp/api/user',
  taskServiceURL: __DEV__ ? 'http://localhost:8889' : 'https://winyx.jp/api/task',
  messageServiceURL: __DEV__ ? 'http://localhost:8890' : 'https://winyx.jp/api/message',
});

export const useAuth = () => {
  const [user, setUser] = useState<LoginRes | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = async () => {
    try {
      const token = await AsyncStorage.getItem('auth_token');
      if (token) {
        apiClient.setAuthToken(token);
        // ユーザー情報を取得してトークンの有効性確認
        const userInfo = await apiClient.getUserInfo();
        setUser(userInfo);
        setIsAuthenticated(true);
      }
    } catch (error) {
      // トークンが無効な場合
      await AsyncStorage.removeItem('auth_token');
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    try {
      const request: LoginReq = { email, password };
      const response = await apiClient.login(request);
      
      await apiClient.setAuthToken(response.accessToken);
      setUser(response);
      setIsAuthenticated(true);
      
      return true;
    } catch (error) {
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      await apiClient.logout();
    } finally {
      await AsyncStorage.removeItem('auth_token');
      apiClient.clearAuthToken();
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  return {
    user,
    isLoading,
    isAuthenticated,
    login,
    logout,
  };
};
```

---

## 第5節 モバイル向けREST APIゲートウェイ設計

### 8.5.1 モバイル専用設定

モバイルアプリは外部からのアクセスのため、内部RPCではなく、REST API（8888）を経由してバックエンドサービスに接続します。

- [ ] モバイル用設定の強化
```go
// backend/user_service/internal/config/config.go
type Config struct {
    rest.RestConf
    
    // CORS設定
    Cors CorsConfig
    
    // モバイル用設定
    Mobile MobileConfig
}

type CorsConfig struct {
    Enable          bool     `json:",default=true"`
    AllowOrigins    []string `json:",default=['*']"`
    AllowMethods    []string `json:",default=['GET','POST','PUT','DELETE','OPTIONS']"`
    AllowHeaders    []string `json:",default=['Content-Type','Authorization','X-Requested-With','X-App-Version','X-Device-ID','X-Platform']"`
    AllowCredentials bool    `json:",default=true"`
    MaxAge          int      `json:",default=3600"`
}

type MobileConfig struct {
    RateLimit       RateLimit
    DeviceTracking  bool   `json:",default=true"`
    VersionCheck    bool   `json:",default=true"`
    MinAppVersion   string `json:",default=1.0.0"`
}
```

### 8.5.2 モバイル専用ミドルウェア

- [ ] デバイス検出とバージョンチェック
```go
// backend/user_service/internal/middleware/mobile.go
func (m *MobileMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // モバイルデバイス検出
        userAgent := r.UserAgent()
        isMobile := m.isMobileDevice(userAgent)
        
        // モバイルアプリのバージョンチェック
        appVersion := r.Header.Get("X-App-Version")
        if isMobile && appVersion != "" {
            if !m.isValidVersion(appVersion) {
                httpx.Error(w, &UpdateRequiredError{
                    Message: "アプリのアップデートが必要です",
                    MinVersion: "1.0.0",
                    UpdateUrl: "https://apps.apple.com/app/winyx",
                })
                return
            }
        }
        
        // デバイス情報のログ記録
        if isMobile {
            deviceID := r.Header.Get("X-Device-ID")
            platform := r.Header.Get("X-Platform")
            
            logx.WithContext(r.Context()).Infof(
                "Mobile request: device=%s, platform=%s, version=%s",
                deviceID, platform, appVersion,
            )
        }
        
        // CORS ヘッダーの設定
        m.setCorsHeaders(w, r)
        
        next(w, r)
    }
}
```

### 8.5.3 レート制限とセキュリティ

- [ ] モバイル向けセキュリティ強化
```go
// モバイルアプリ向けレート制限
func (m *MobileMiddleware) applyRateLimit(r *http.Request) error {
    deviceID := r.Header.Get("X-Device-ID")
    if deviceID == "" {
        return errors.New("Device ID required for mobile clients")
    }
    
    // デバイス毎のレート制限チェック
    key := fmt.Sprintf("rate_limit:mobile:%s", deviceID)
    
    // Redisベースのレート制限実装
    // ... レート制限ロジック
    
    return nil
}
```

---

## 第6節 開発ワークフローの統合

### 8.6.1 マルチクライアント開発フロー

- [ ] 統合開発ワークフロー
```bash
# 1. 契約ファイルの編集（マイクロサービス対応）
vim /var/www/winyx/contracts/user_service/user.api
vim /var/www/winyx/contracts/task_service/task.api
vim /var/www/winyx/contracts/message_service/message.api

# 2. 全クライアント向けコード生成
./scripts/sync_contracts.sh
# → TypeScript (Next.js)
# → Dart (Flutter)  
# → TypeScript (React Native)
# → OpenAPI仕様書

# 3. 各クライアントでの開発
## Web開発
cd frontend && npm run dev

## Flutter開発  
cd mobile/flutter_app && flutter run

## React Native開発
cd mobile/react_native_app && npx react-native run-android
```

### 8.6.2 開発環境の起動

- [ ] 開発サーバーの一括起動
```bash
# スクリプトで一括起動
#!/bin/bash
# start_dev.sh

echo "🚀 Winyx開発環境を起動中..."

# バックエンドサービス起動（マイクロサービス構成）
cd backend/user_service
go run user_service.go -f etc/user_service-api.yaml &
USER_SERVICE_PID=$!

cd ../task_service
go run task_service.go -f etc/task_service-api.yaml &
TASK_SERVICE_PID=$!

cd ../message_service
go run message_service.go -f etc/message_service-api.yaml &
MESSAGE_SERVICE_PID=$!

# フロントエンド起動  
cd ../../frontend
npm run dev &
FRONTEND_PID=$!

# Flutter (オプション)
if [ "$1" = "flutter" ]; then
    cd ../mobile/flutter_app
    flutter run &
    FLUTTER_PID=$!
fi

echo "✅ 開発環境が起動しました"
echo "🌐 Web: http://localhost:3000"
echo "🔧 API: http://localhost:8888"

# Ctrl+C で全て停止
trap 'kill $USER_SERVICE_PID $TASK_SERVICE_PID $MESSAGE_SERVICE_PID $FRONTEND_PID $FLUTTER_PID' EXIT
wait
```

### 8.6.3 テスト環境

- [ ] 統合テストスクリプト
```bash
#!/bin/bash
# test_all.sh

echo "🧪 全クライアントのテストを実行中..."

# バックエンドテスト（全マイクロサービス）
cd backend/user_service && go test ./...
cd ../task_service && go test ./...
cd ../message_service && go test ./...

# フロントエンドテスト
cd ../../frontend  
npm test

# Flutterテスト
cd ../mobile/flutter_app
flutter test

# React Nativeテスト (オプション)
if [ -d "../react_native_app" ]; then
    cd ../react_native_app
    npm test
fi

echo "✅ 全テストが完了しました"
```

---

## 第7節 モバイルアプリテスト・デバッグ

### 8.7.1 Flutter単体テスト

- [ ] APIクライアントのテスト
```dart
// test/api_client_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:mockito/mockito.dart';
import '../lib/generated/api_client.dart';
import '../lib/generated/models.dart';

class MockHttpClient extends Mock implements http.Client {}

void main() {
  group('WinyxApiClient Tests', () {
    late WinyxApiClient apiClient;
    late MockHttpClient mockHttpClient;

    setUp(() {
      mockHttpClient = MockHttpClient();
      apiClient = WinyxApiClient(
        baseUrl: 'https://test.winyx.jp',
      );
    });

    test('ログインが正常に動作すること', () async {
      // モックレスポンス設定
      when(mockHttpClient.post(
        any,
        headers: anyNamed('headers'),
        body: anyNamed('body'),
      )).thenAnswer((_) async => http.Response(
        '''
        {
          "access_token": "test_token_123",
          "expire_time": 1640995200,
          "user_id": 1,
          "name": "テストユーザー"
        }
        ''',
        200,
      ));

      // テスト実行
      final request = LoginReq(
        email: 'test@example.com',
        password: 'password123',
      );

      final response = await apiClient.login(request);

      // 検証
      expect(response.accessToken, equals('test_token_123'));
      expect(response.expireTime, equals(1640995200));
    });

    test('認証エラーが適切に処理されること', () async {
      // エラーレスポンス設定
      when(mockHttpClient.post(any, 
          headers: anyNamed('headers'),
          body: anyNamed('body')))
          .thenAnswer((_) async => http.Response(
        '''
        {
          "error": "invalid_credentials",
          "message": "メールアドレスまたはパスワードが正しくありません"
        }
        ''',
        401,
      ));

      // テスト実行とエラー検証
      final request = LoginReq(
        email: 'invalid@example.com',
        password: 'wrong_password',
      );

      expect(
        () => apiClient.login(request),
        throwsA(isA<ApiException>()),
      );
    });
  });
}
```

### 8.7.2 統合テスト

- [ ] Flutter統合テスト
```dart
// integration_test/app_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:winyx_app/main.dart' as app;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('アプリ統合テスト', () {
    testWidgets('ログインフローのテスト', (WidgetTester tester) async {
      // アプリ起動
      app.main();
      await tester.pumpAndSettle();

      // ログイン画面の確認
      expect(find.text('Winyxにログイン'), findsOneWidget);
      expect(find.byType(TextFormField), findsNWidgets(2));

      // ログイン情報入力
      await tester.enterText(
        find.byType(TextFormField).first,
        'test@example.com',
      );
      await tester.enterText(
        find.byType(TextFormField).last,
        'password123',
      );

      // ログインボタンをタップ
      await tester.tap(find.text('ログイン'));
      await tester.pumpAndSettle();

      // ダッシュボード画面への遷移を確認
      expect(find.text('ダッシュボード'), findsOneWidget);
    });
  });
}
```

### 8.7.3 デバッグツール

- [ ] Flutter用デバッグ設定
```dart
// lib/utils/debug_tools.dart
class DebugTools {
  static bool get isDebugMode {
    bool debugMode = false;
    assert(debugMode = true);
    return debugMode;
  }

  static void logApiRequest(String method, String url, Map<String, dynamic>? data) {
    if (isDebugMode) {
      print('🌐 API Request: $method $url');
      if (data != null) {
        print('📦 Data: $data');
      }
    }
  }

  static void logApiResponse(String url, int statusCode, dynamic response) {
    if (isDebugMode) {
      print('✅ API Response: $url - Status: $statusCode');
      print('📦 Response: $response');
    }
  }

  static void logError(String message, dynamic error, StackTrace? stackTrace) {
    if (isDebugMode) {
      print('❌ Error: $message');
      print('🐛 Details: $error');
      if (stackTrace != null) {
        print('📍 Stack: $stackTrace');
      }
    }
  }
}
```

---

## まとめ

本章で構築したモバイルアプリケーション開発環境により：

1. **統一された開発体験** - 単一の契約ファイルからすべてのプラットフォーム対応
2. **型安全な開発** - コンパイル時での型チェックによる品質向上
3. **自動化されたワークフロー** - 契約変更時の自動コード生成
4. **クロスプラットフォーム対応** - Flutter、React Native、ネイティブアプリすべてに対応
5. **統合テスト環境** - 単体テストから統合テストまでの完全なテスト環境
6. **効率的なデバッグ** - 開発効率を向上させるデバッグツール

**Contract-Driven Mobile Development with Microservices**により、Web、モバイルすべてのクライアントがマイクロサービス構成に対応した一貫した品質で開発できる環境が整いました。これにより、チーム全体での開発効率と品質の大幅な向上が実現されます。