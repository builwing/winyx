# 第9章 システム監視ダッシュボード構築

> 本章では、Go-Zero GatewayサービスとNext.jsを連携したリアルタイムシステム監視ダッシュボードの構築について解説します。

---

## 第1節 監視ダッシュボード概要

### 9.1.1 ダッシュボードの目的

Winyxプロジェクトでは、システム全体の健全性とパフォーマンスを監視するため、リアルタイムダッシュボードを構築します。これにより：

- **システムの可視化**: 各サービスの稼働状況を一目で確認
- **問題の早期発見**: アラートやメトリクスによる異常検知
- **パフォーマンス分析**: API使用統計や応答時間の追跡
- **運用効率の向上**: 管理作業の簡素化と自動化

### 9.1.2 アーキテクチャ概要

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Next.js       │────▶│  Dashboard      │────▶│  Monitoring     │
│  Dashboard      │ HTTP│  Gateway        │     │  Targets        │
│  (Port: 3000)   │     │  (Port: 8889)   │     │  (各サービス)    │
└─────────────────┘     └─────────────────┘     └─────────────────┘
         │                        │                        │
         │                        ▼                        │
         │               ┌─────────────────┐               │
         │               │     Redis       │               │
         │               │ (メトリクス保存) │               │
         │               └─────────────────┘               │
         │                                                 │
         ▼                                                 ▼
┌─────────────────┐                              ┌─────────────────┐
│ React Query     │                              │   MySQL DB      │
│ (データキャッシュ) │                              │  (統計データ)     │
└─────────────────┘                              └─────────────────┘
```

### 9.1.3 主な機能

- **システムヘルス監視**: 各サービスの稼働状況とレスポンス時間
- **リアルタイムメトリクス**: CPU・メモリ・ディスク使用率
- **API使用統計**: エンドポイント別の利用状況と性能分析
- **設定情報表示**: システム環境とバージョン情報
- **自動更新**: 設定可能な間隔でのデータ更新

---

## 第2節 Go-Zero Dashboard Gateway実装

### 9.2.1 Gatewayサービスの作成

Go-Zero CLI を使用してダッシュボード用Gatewayサービスを構築します。

- [ ] プロジェクト構造の確認
```bash
cd /var/www/winyx/backend
mkdir dashboard_gateway
cd dashboard_gateway
```

### 9.2.2 API契約ファイルの設計

- [ ] ダッシュボード専用契約ファイル
```bash
vim dashboard_gateway.api
```

契約ファイルの主要定義：

```go
syntax = "v1"

info (
	title:   "Winyx Dashboard Gateway API"
	desc:    "Winyxプロジェクトのダッシュボード機能を提供するGateway API"
	author:  "Winyx Team"
	version: "1.0"
)

// システムヘルス関連の型定義
type (
	SystemHealthRes {
		Status       string          `json:"status"`                      // システムステータス
		Timestamp    int64           `json:"timestamp"`                   // 確認時のタイムスタンプ
		Services     []ServiceStatus `json:"services"`                   // サービス別の状況
		Database     DatabaseStatus  `json:"database"`                   // データベース状況
		Memory       MemoryStatus    `json:"memory"`                     // メモリ使用状況
		ResponseTime int64           `json:"response_time_ms"`            // 応答時間
	}

	ServiceStatus {
		Name         string `json:"name"`                              // サービス名
		Status       string `json:"status"`                           // サービス状況
		Port         int    `json:"port,optional"`                    // ポート番号
		LastCheck    int64  `json:"last_check"`                       // 最後のチェック時刻
		ResponseTime int64  `json:"response_time_ms"`                 // 応答時間
		ErrorCount   int    `json:"error_count"`                      // エラー数
		Version      string `json:"version,optional"`                 // サービスバージョン
	}
)

// API定義
@server(
	group: health
	prefix: /api/dashboard
)
service dashboard_gateway-api {
	@doc "システム全体のヘルスチェック"
	@handler systemHealth
	get /health returns (SystemHealthRes)
}
```

### 9.2.3 Go-Zeroコード生成

- [ ] 契約ファイルからコード生成
```bash
goctl api go -api dashboard_gateway.api -dir . -style gozero
```

これにより以下の構造が生成されます：

```
dashboard_gateway/
├── dashboard_gateway.api           # API契約ファイル
├── dashboardgateway.go            # メインエントリーポイント
├── etc/
│   └── dashboardgateway-api.yaml  # 設定ファイル
├── internal/
│   ├── config/
│   │   └── config.go              # 設定構造体
│   ├── handler/                   # HTTPハンドラー
│   │   ├── health/
│   │   │   └── systemhealthhandler.go
│   │   ├── stats/
│   │   │   └── apistatshandler.go
│   │   ├── monitoring/
│   │   │   └── realtimemetricshandler.go
│   │   └── config/
│   │       └── configinfohandler.go
│   ├── logic/                     # ビジネスロジック
│   │   ├── health/
│   │   │   └── systemhealthlogic.go
│   │   └── ...
│   ├── svc/
│   │   └── servicecontext.go      # サービスコンテキスト
│   └── types/
│       └── types.go               # 型定義
```

### 9.2.4 設定ファイルの拡張

- [ ] 監視対象とデータベース設定を追加
```yaml
# etc/dashboardgateway-api.yaml
Name: dashboard_gateway-api
Host: 0.0.0.0
Port: 8889

Log:
  Level: info

# データベース設定（統計用）
DataSource: "user:password@tcp(localhost:3306)/winyx?charset=utf8mb4&parseTime=true"

# Redis設定（メトリクス保存用）
Redis:
  Host: localhost:6379
  Type: node

# 監視対象サービス設定
MonitoringTargets:
  - name: "test_api"
    url: "http://localhost:8888"
    type: "rest"
  - name: "user_rpc"
    url: "localhost:9090"
    type: "rpc"

# システム情報
System:
  Version: "1.0.0"
  Environment: "development"
```

---

## 第3節 監視ロジックの実装

### 9.3.1 システムヘルスチェック実装

- [ ] ヘルスチェックロジックの実装
```go
// internal/logic/health/systemhealthlogic.go
func (l *SystemHealthLogic) SystemHealth() (resp *types.SystemHealthRes, err error) {
	startTime := time.Now()
	
	// サービス状態をチェック
	services := l.checkServices()
	
	// データベース状態をチェック
	database := l.checkDatabase()
	
	// メモリ状態をチェック
	memory := l.checkMemory()
	
	// 全体的なステータスを判定
	status := "healthy"
	for _, service := range services {
		if service.Status == "down" {
			status = "unhealthy"
			break
		} else if service.Status == "degraded" && status != "unhealthy" {
			status = "degraded"
		}
	}
	
	responseTime := time.Since(startTime).Milliseconds()
	
	return &types.SystemHealthRes{
		Status:       status,
		Timestamp:    time.Now().Unix(),
		Services:     services,
		Database:     database,
		Memory:       memory,
		ResponseTime: responseTime,
	}, nil
}
```

### 9.3.2 サービス監視の実装

```go
func (l *SystemHealthLogic) checkServices() []types.ServiceStatus {
	var services []types.ServiceStatus
	
	for _, target := range l.svcCtx.Config.MonitoringTargets {
		status := l.checkSingleService(target)
		services = append(services, status)
	}
	
	return services
}

func (l *SystemHealthLogic) checkSingleService(target config.MonitoringTarget) types.ServiceStatus {
	startTime := time.Now()
	status := "up"
	
	client := &http.Client{
		Timeout: 5 * time.Second,
	}
	
	healthUrl := target.Url
	if target.Type == "rest" {
		healthUrl += "/health"
	}
	
	resp, err := client.Get(healthUrl)
	responseTime := time.Since(startTime).Milliseconds()
	
	if err != nil {
		status = "down"
	} else if resp.StatusCode >= 400 {
		status = "degraded"
	}
	
	if resp != nil {
		resp.Body.Close()
	}
	
	return types.ServiceStatus{
		Name:         target.Name,
		Status:       status,
		LastCheck:    time.Now().Unix(),
		ResponseTime: responseTime,
		ErrorCount:   0, // TODO: Redisから取得
		Version:      "1.0.0",
	}
}
```

### 9.3.3 リアルタイムメトリクス実装

```go
// internal/logic/monitoring/realtimemetricslogic.go
func (l *RealtimeMetricsLogic) RealtimeMetrics() (resp *types.RealtimeMetricsRes, err error) {
	// システムメトリクスを収集
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	
	// CPUとメモリ使用率を計算
	memoryUsage := float64(m.Alloc) / float64(m.Sys) * 100
	if memoryUsage > 100 {
		memoryUsage = 100
	}
	
	return &types.RealtimeMetricsRes{
		CurrentTime:    time.Now().Unix(),
		ActiveSessions: 15, // TODO: 実際のセッション数を取得
		RequestsPerMin: 120, // TODO: 実際のリクエスト数を計算
		CpuUsage:       45.2, // TODO: 実際のCPU使用率を取得
		MemoryUsage:    memoryUsage,
		DiskUsage:      67.8, // TODO: 実際のディスク使用率を取得
		NetworkIn:      1024*1024*5,
		NetworkOut:     1024*1024*3,
	}, nil
}
```

### 9.3.4 API統計実装

```go
// internal/logic/stats/apistatslogic.go
func (l *ApiStatsLogic) ApiStats(req *types.ApiStatsReq) (resp *types.ApiStatsRes, err error) {
	period := req.Period
	if period == "" {
		period = "24h"
	}
	
	return &types.ApiStatsRes{
		Period:          period,
		TotalRequests:   15420,
		SuccessRequests: 14850,
		ErrorRequests:   570,
		AvgResponseTime: 156,
		TopEndpoints: []types.EndpointStat{
			{
				Path:            "/api/auth/login",
				Method:          "POST",
				RequestCount:    2345,
				AvgResponseTime: 89,
				ErrorRate:       2.1,
			},
		},
		ErrorBreakdown: []types.ErrorStat{
			{
				StatusCode: 401,
				Count:      234,
				Message:    "Unauthorized",
			},
		},
	}, nil
}
```

---

## 第4節 フロントエンド実装

### 9.4.1 TypeScript型定義の生成

既存の契約駆動開発システムを活用して型定義を自動生成します：

- [ ] 型生成スクリプトの更新
```javascript
// scripts/generate_frontend_types.js
const CONFIG = {
  apiFiles: [
    path.join(__dirname, '../backend/test_api/test_api.api'),
    path.join(__dirname, '../backend/dashboard_gateway/dashboard_gateway.api'), // 追加
  ],
  outputDir: path.join(__dirname, '../frontend/src/types/generated'),
  clientOutputDir: path.join(__dirname, '../frontend/src/lib/api/generated'),
};
```

- [ ] 型定義の生成実行
```bash
node scripts/generate_frontend_types.js
```

### 9.4.2 APIクライアントの実装

ダッシュボード専用のAPIクライアントを実装：

```typescript
// src/lib/api/dashboard.ts
import { apiRequest } from './client';
import { 
  SystemHealthRes, 
  ApiStatsRes, 
  RealtimeMetricsRes, 
  ConfigRes 
} from '@/types/generated/types';

export const dashboardApi = {
  getSystemHealth: (): Promise<SystemHealthRes> => {
    return apiRequest.get<SystemHealthRes>('/api/dashboard/health');
  },

  getApiStats: (params?: any): Promise<ApiStatsRes> => {
    const query = params ? `?${new URLSearchParams(params)}` : '';
    return apiRequest.get<ApiStatsRes>(`/api/dashboard/stats${query}`);
  },

  getRealtimeMetrics: (): Promise<RealtimeMetricsRes> => {
    return apiRequest.get<RealtimeMetricsRes>('/api/dashboard/metrics/realtime');
  },

  getConfigInfo: (): Promise<ConfigRes> => {
    return apiRequest.get<ConfigRes>('/api/dashboard/config');
  },
};
```

### 9.4.3 React Queryフックの実装

```typescript
// src/lib/api/dashboard-hooks.ts
import { useQuery } from '@tanstack/react-query';
import { dashboardApi } from './dashboard';

export function useSystemHealth() {
  return useQuery({
    queryKey: ['dashboard', 'systemHealth'],
    queryFn: () => dashboardApi.getSystemHealth(),
    refetchInterval: 30000, // 30秒間隔で自動更新
  });
}

export function useRealtimeMetrics() {
  return useQuery({
    queryKey: ['dashboard', 'realtimeMetrics'],
    queryFn: () => dashboardApi.getRealtimeMetrics(),
    refetchInterval: 10000, // 10秒間隔で自動更新
  });
}

export function useApiStats(params?: any) {
  return useQuery({
    queryKey: ['dashboard', 'apiStats', params],
    queryFn: () => dashboardApi.getApiStats(params),
    refetchInterval: 60000, // 1分間隔で自動更新
  });
}

export function useConfigInfo() {
  return useQuery({
    queryKey: ['dashboard', 'configInfo'],
    queryFn: () => dashboardApi.getConfigInfo(),
    staleTime: 5 * 60 * 1000, // 5分間キャッシュ
  });
}
```

---

## 第5節 ダッシュボードUI実装

### 9.5.1 メインダッシュボードページ

```typescript
// src/app/dashboard/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { 
  useSystemHealth, 
  useApiStats, 
  useRealtimeMetrics, 
  useConfigInfo 
} from '@/lib/api/dashboard-hooks';

export default function DashboardPage() {
  const [refreshInterval, setRefreshInterval] = useState<number | null>(null);

  const { data: healthData, refetch: refetchHealth } = useSystemHealth();
  const { data: metricsData, refetch: refetchMetrics } = useRealtimeMetrics();
  const { data: statsData, refetch: refetchStats } = useApiStats();
  const { data: configData, refetch: refetchConfig } = useConfigInfo();

  // 自動リフレッシュ設定
  useEffect(() => {
    if (refreshInterval) {
      const interval = setInterval(() => {
        refetchHealth();
        refetchMetrics();
        refetchStats();
      }, refreshInterval * 1000);
      
      return () => clearInterval(interval);
    }
  }, [refreshInterval, refetchHealth, refetchMetrics, refetchStats]);

  return (
    <div className="container mx-auto p-6 space-y-6">
      {/* システム概要 */}
      <SystemOverview healthData={healthData} />
      
      {/* リアルタイムメトリクス */}
      <MetricsGrid metricsData={metricsData} />
      
      {/* サービス詳細とAPI統計 */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <ServiceStatusCard healthData={healthData} />
        <ApiStatsCard statsData={statsData} />
      </div>
      
      {/* システム情報 */}
      <SystemInfoCard configData={configData} />
    </div>
  );
}
```

### 9.5.2 システム概要コンポーネント

```typescript
function SystemOverview({ healthData }: { healthData: SystemHealthRes | undefined }) {
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'healthy': return 'bg-green-500';
      case 'degraded': return 'bg-yellow-500';
      case 'unhealthy': return 'bg-red-500';
      default: return 'bg-gray-500';
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          システム全体の状態
          <Badge className={getStatusColor(healthData?.status || 'unknown')}>
            {healthData?.status || 'Unknown'}
          </Badge>
        </CardTitle>
        <CardDescription>
          最終確認: {healthData?.timestamp ? new Date(healthData.timestamp * 1000).toLocaleString('ja-JP') : 'N/A'}
        </CardDescription>
      </CardHeader>
      <CardContent>
        {/* システム情報表示 */}
      </CardContent>
    </Card>
  );
}
```

### 9.5.3 リアルタイムメトリクス表示

```typescript
function MetricsGrid({ metricsData }: { metricsData: RealtimeMetricsRes | undefined }) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      <MetricCard
        title="アクティブセッション"
        value={metricsData?.active_sessions || 0}
        icon={<Users className="w-4 h-4" />}
      />
      <MetricCard
        title="リクエスト/分"
        value={metricsData?.requests_per_minute || 0}
        icon={<TrendingUp className="w-4 h-4" />}
      />
      <MetricCard
        title="CPU使用率"
        value={`${metricsData?.cpu_usage_percent?.toFixed(1) || 0}%`}
        icon={<Activity className="w-4 h-4" />}
        progress={metricsData?.cpu_usage_percent || 0}
      />
      <MetricCard
        title="メモリ使用率"
        value={`${metricsData?.memory_usage_percent?.toFixed(1) || 0}%`}
        icon={<MemoryStick className="w-4 h-4" />}
        progress={metricsData?.memory_usage_percent || 0}
      />
    </div>
  );
}
```

### 9.5.4 サービス状況表示

```typescript
function ServiceStatusCard({ healthData }: { healthData: SystemHealthRes | undefined }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>サービス状況</CardTitle>
        <CardDescription>各サービスの動作状態</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-3">
          {healthData?.services?.map((service, index) => (
            <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
              <div className="flex items-center gap-3">
                <div className={`w-3 h-3 rounded-full ${
                  service.status === 'up' ? 'bg-green-500' :
                  service.status === 'degraded' ? 'bg-yellow-500' : 'bg-red-500'
                }`} />
                <div>
                  <p className="font-medium">{service.name}</p>
                  <p className="text-sm text-gray-600">
                    応答時間: {service.response_time_ms}ms
                  </p>
                </div>
              </div>
              <Badge variant={service.status === 'up' ? 'default' : 'destructive'}>
                {service.status}
              </Badge>
            </div>
          )) || <p className="text-gray-500">データなし</p>}
        </div>
      </CardContent>
    </Card>
  );
}
```

---

## 第6節 運用とテスト

### 9.6.1 ダッシュボードサービスの起動

- [ ] Gatewayサービスの起動
```bash
cd /var/www/winyx/backend/dashboard_gateway
go run dashboardgateway.go -f etc/dashboardgateway-api.yaml
```

- [ ] フロントエンドの起動
```bash
cd /var/www/winyx/frontend
npm run dev
```

- [ ] ダッシュボードアクセス
```
http://localhost:3000/dashboard
```

### 9.6.2 APIエンドポイントのテスト

- [ ] ヘルスチェックの確認
```bash
curl http://localhost:8889/api/dashboard/health
```

- [ ] リアルタイムメトリクスの確認
```bash
curl http://localhost:8889/api/dashboard/metrics/realtime
```

- [ ] API統計の確認
```bash
curl http://localhost:8889/api/dashboard/stats?period=24h
```

### 9.6.3 データ監視の検証

1. **サービス停止テスト**: test_apiサービスを停止してダッシュボードの状態変化を確認
2. **負荷テスト**: APIに負荷をかけてメトリクス値の変動を確認
3. **自動更新テスト**: 設定した間隔でデータが更新されることを確認

---

## 第7節 高度な機能拡張

### 9.7.1 アラート機能

```go
// アラート判定ロジック
type AlertRule struct {
    Metric    string  `json:"metric"`
    Threshold float64 `json:"threshold"`
    Condition string  `json:"condition"` // "gt", "lt", "eq"
    Action    string  `json:"action"`    // "email", "slack"
}

func (l *SystemHealthLogic) checkAlerts(metrics *types.RealtimeMetricsRes) {
    rules := l.getAlertRules()
    
    for _, rule := range rules {
        if l.evaluateRule(rule, metrics) {
            l.triggerAlert(rule)
        }
    }
}
```

### 9.7.2 履歴データの保存

```go
// メトリクス履歴保存
func (l *RealtimeMetricsLogic) SaveMetrics(metrics *types.RealtimeMetricsRes) error {
    // Redisに時系列データとして保存
    key := fmt.Sprintf("metrics:%d", time.Now().Unix())
    data, _ := json.Marshal(metrics)
    
    return l.svcCtx.Redis.Set(key, data, time.Hour*24*30) // 30日間保持
}
```

### 9.7.3 チャートとグラフ表示

```typescript
// Chart.jsを使用したメトリクス可視化
import { Line } from 'react-chartjs-2';

function MetricsChart({ data }: { data: any[] }) {
  const chartData = {
    labels: data.map(d => new Date(d.timestamp * 1000).toLocaleTimeString()),
    datasets: [{
      label: 'CPU使用率',
      data: data.map(d => d.cpu_usage_percent),
      borderColor: 'rgb(75, 192, 192)',
      tension: 0.1
    }]
  };

  return <Line data={chartData} />;
}
```

---

## 第8節 セキュリティとパフォーマンス

### 9.8.1 認証とアクセス制御

```go
// ダッシュボード用認証ミドルウェア
func (m *AuthMiddleware) Handle(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        
        if !m.validateDashboardAccess(token) {
            httpx.Error(w, errors.New("ダッシュボードへのアクセスが拒否されました"))
            return
        }
        
        next(w, r)
    }
}
```

### 9.8.2 データキャッシュ最適化

```typescript
// React Query設定の最適化
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5分間はfreshとして扱う
      cacheTime: 1000 * 60 * 30, // 30分間キャッシュ
      retry: 3,
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
});
```

### 9.8.3 レスポンス圧縮

```go
// gzip圧縮の有効化
func main() {
    var c config.Config
    conf.MustLoad(*configFile, &c)
    
    server := rest.MustNewServer(c.RestConf, rest.WithGzip())
    defer server.Stop()
    
    ctx := svc.NewServiceContext(c)
    handler.RegisterHandlers(server, ctx)
    
    server.Start()
}
```

---

## まとめ

本章で構築したシステム監視ダッシュボードにより：

1. **統合監視環境** - 全サービスの統一監視が可能
2. **リアルタイム可視化** - システム状態の即座な把握
3. **契約駆動開発** - バックエンドとフロントエンドの型安全な連携
4. **自動更新機能** - 手動操作不要でのデータ更新
5. **拡張可能性** - アラートやチャート機能の追加が容易

**Dashboard-Driven Operations**により、Winyxプロジェクトの運用効率と安定性が大幅に向上します。Go-ZeroとNext.jsの連携によるリアルタイム監視システムは、現代的なマイクロサービス環境での運用に不可欠な機能を提供します。

次章では、本格運用に向けたCI/CDパイプラインの構築について解説します。